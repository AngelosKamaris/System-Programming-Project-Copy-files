Καμάρης Άγγελος
sdi1900070


    Έχω τρέξει το παράδειγμα Server στα linux της σχολής και σε vm του υπολογιστή μου.

ο φάκελος περιέχει:
-Server: Φάκελος που περιέχει μερικά αρχεία για παραδείγματα
-dataServer.cpp: Το αρχείο στο οποίο υπάρχει ο Server που ζητάει η εργασία
-Makefile: Αρχείο για την μεταγλώττιση των αρχείων
-ReadMe.txt: Το παρόν αρχείο που εξηγεί την εργασία
-remoteClient.cpp: Το αρχείο στο οποίο υπάρχει ο Client που ζητάει η εργασία


Server:
    Ένας φάκελος που περιέχει τον φάκελο Folder1, ο οποίος περιέχει τα αρχεία,
file4, file5 και τα αρχεία file1-3. Έχουν δωθεί σαν ένα απλό παράδειγμα που
χρησιμοποίησα ανάμεσα στα άλλα.


dataServer.cpp:
    Ένα αρχείο γραμμένο σε c++. Βασισμένο σε μεγάλο βαθμό από το αρχείο του μαθήματος
int_str_server.c. Περιέχει τις συναρτήσεις: recurdir η οποία ανοίγει έναν φάκελο που
δέχεται και αν αυτός ο φάκελος έχει άλλους φακέλους καλεί ξανά τον εαυτό της γι'
αυτόν τον φάκελο, ενώ αν έχει αρχεία τα προσθέτει στην ουρά που ζητάει η εκφώνηση και
επιστρέφει τον αριθμό των αρχείων που υπήρχαν στον φάκελο και τους εσωτερικούς του φακέλους,
comunicators που είναι το communicator thread που ζητάει η εκφώνηση. Δέχεται τον αριθμό του
socket, διαβάζει το όνομα του αρχείου που του στέλνει ο client και το τοποθετεί στην προηγούμενη
συνάρτηση. Υπάρχουν τα workers που είναι τα thread από το pool που ζητάει η εκφώνηση. δεν
δέχονται όρισμα, τρέχουν από την αρχή του server και ψάχνουν συνεχώς την ουρά να πάρουν
αρχεία. αφού τα πάρουν, στέλνουν το όνομά τους, το περιεχόμενό τους και το μέγεθός τους στον
client. Υπάρχουν επίσης δομές node και queue που υλοποίησα για να δημιουργήσω την ουρά και
χρησιμοποιούν τις συναρτήσεις queue_init για αρχικοποίηση της ουράς, enqueue για να τοποθετήσουν
κόμβους στην ουρά dequeue για να τους αφαιρέσουν από εκεί και queue_destroy για να αποδεσμευτεί
η μνήμη τους. ο κόμβος κρατάει πληροφορίες για το socket στο οποίο θα σταλούν τα δεδομένα και το
όνομα του αρχείου. Χρησιμοποιώ το mutex qmutex για να κάνω lock και unlock όταν βάζω ή βγάζω κάτι
στην ουρά, ώστε να αποφύγω race condition, καθώς και όταν γράφω στον client. Έχω 2 conditions τα
οποία κάνουν την ουρά μου να σταματάει να βάζει όταν είναι γεμάτη και να βγάζει όταν είναι άδεια
(αποφεύγω έτσι τυχών περιττές αναζητήσεις). Έχω έναν map που κρατάει σαν κλειδί τον αριθμό του
socket και σαν δεδομένα τα πόσα αρχεία έχουν σταλεί στον client, έτσι ώστε όταν ο αριθμός των
αρχείων που έχουν μπει ισοδυναμεί με αυτόν που έχουν βγει, να κλείσω το socket. Τέλος έχω μια
global μεταβλητή int blocksize που κρατάει το μέγεθός του block. global είναι επίσης και  η ουρά
για λόγους ευκολίας.
    Η main ξεκινόντας, δίνει τις τιμές που της δόθηκαν στην κλήση στις κατάλληλες μεταβλητές και
αρχικοποιεί την ουρά, ύστερα το thread pool και τέλος socket από το οποίο θα δέχεται συνδέσεις.
Μπαίνει σε έναν ατέρμονο βρόγχο, ο οποίος ελέγχει για συνδέσεις. μόλις συνδεθεί, δημιουργεί ένα
καινούργιο communicator thread, δίνοντάς του ως όρισμα την μεταβλητή του αριθμού του socket.
Για να τερματήσει ο server, χρειάζεται CTRL+C.
    Το καινούργιο thread που δημιουργήθηκε στην Main, θα διαβάσει το socket, για να πάρει το όνομα
του φακέλου που πρέπει να στείλει. Θα δώσει στο map wrfiles σαν κλειδί την τιμή του socket και σαν
value, το 0, για να ξεκινήσει να μετράει τα αρχεία που έχουν γραφτεί. Θα καλέσει την συνάρτηση
recurdir με ορίσματα το socket και το όνομα του φακέλου και κρατάει τον αριθμό που του επιστρέφει.
Ύστερα περιμένει μέχρι τα αρχεία που έχουν σταλεί να είναι ίσα με τα αρχεία που βρέθηκαν και
κλείνει το socket.
    Η recurdir ανοίγει το directory που της δίνεται, κοιτάει τα αρχεία μέσα σε αυτό, αν είναι
directories καλεί τον εαυτό της με όρισμα αυτά και προσθέτει την τιμή που επιστρέφουν στον αριθμό
των αρχείων που θα επιστρέψει. Αν είναι αρχεία, δημιουργεί κόμβους από το socket και το όνομα του
αρχείου, καλεί την enqueue, αν η ουρά είναι γεμάτη περιμένει σήμα από τους workers ότι έχει αδειάσει
η ουρά και ύστερα τα τοποθετεί στην ουρά. Για να το καταφέρει αυτό καλεί mutex το οποίο κλειδώνει
και ξεκλειδώνει όσο μπαίνει ο κόμβος στην ουρά, ώστε να μην πάνε όλα τα threads ταυτόχρονα να βάλουν
κάποιον κόμβο στην ουρά και χρησιμοποιεί και ένα condition ώστε να στείλει σήμα στους workers ότι
δεν είναι πλέον άδεια η ουρά. Μόλις τελειώσει με τα αρχεία κλείνει το directory και επιστρέφει τον
αριθμό των αρχείων που βρήκε (π.χ. 3 αρχεία σε αυτόν τον φάκελο και 2 σε έναν εσωτερικό, επιστρέφει 5).
    Τέλος οι workers επαναλαμβάνονται από την αρχή του server και ελέγχουν αν είναι άδεια η ουρά, αφού
πρώτα κλειδώσουν το mutex, ώστε να μην διαβάζουν όλα μαζί το ίδιο αλλιώς περιμένουν σήμα από το condition,
για να ξέρουν ότι δεν είναι άδεια πλέον η ουρά και μπορούν να βγάλουν αρχεία. Αφού βγάλουν τ'αρχεία,
στέλνουν σήμα στο condition ότι δεν είναι γεμάτη η ουρά, το όνομά του αρχείου που υπάρχει στο node για το
socket που βρίσκεται εκεί μαζί με ./ στην αρχή  για να καταλάβει ο client ότι πρόκειτε για όνομα, στέλνουν
\s για να δείξουν πότε σταματάει το όνομα και αρχίζουν τα περιεχόμενα. Ανοίγει το αρχείο, το διαβάζει
ανα μπλοκ και κάθε μπλοκ που διαβάζει το στέλνει και στον client. Κρατάει το μέγεθος του αρχείου και
μόλις στείλει όλα τα μπλοκ, στέλνει σήμα ότι αρχίζουν τα metadata (~.), στέλνει το μέγεθος και στέλνει
σήμα ότι τελείωσαν (.~). Ύστερα προσθέτει στον χάρτη με κλειδί το socket που έγραφε, 1, μιας και τόσα
αρχεία έβγαλε και ελευθερώνει το mutex.

Makefile:
    make για μεταγλώττιση αρχείων, make clean για καθάρισμα.

remoteClient.cpp
     Ένα αρχείο γραμμένο σε c++. Βασισμένο σε μεγάλο βαθμό από το αρχείο του μαθήματος
int_str_client.c. Περιέχει την συνάρτηση dirmake η οποία φτιάχνει αναδρομικά φακέλους για τα αρχεία που της
δίνονται.
    Η main ξεκινόντας, δίνει τις τιμές που της δόθηκαν στην κλήση στις κατάλληλες μεταβλητές και δημιουργεί
το socket. Συνδέεται με τον server και αφού συνδεθεί στέλνει στο socket το όνομα του φακέλου που του δόθηκε
στην κλήση. Ύστερα αρχικοποιεί έναν buffer μαζί με άλλους συγκεκριμένους buffer (ένας για το όνομα του αρχείου
και ένας για το metadata) και μερικές σημαίες που θα χρειαστεί για να ξέρει τι στέλνεται από τον Server.
Όσο ο server στέλνει στο socket, ο client τα δέχεται( σε μέγεθος buffer μιας και δεν ζητείτε να διαβάζονται
τα δεδομένα σε blocks) και ελέγχει στον buffer αν του δίνεται όνομα αρχείου, δεδομένα αρχείου ή metadata.
    όνομα αρχείου: καλεί την συνάρτηση dirmake για το μονοπάτι του ονόματος, η dirmake θα φτιάξει όλους τους
φακέλους, ώστε το αρχείο να σωθεί στο σωστό μονοπάτι, ελέγχει αν το αρχείο υπάρχει ήδη, αν υπάρχει το
διαγράφει και το δημιουργεί, κρατόντας τον αριθμό του. Αν δεν έχει φτάσει στο τέλος του ονόματος, απλά το
αντιγράφει γράμμα γράμμα.
    δεδομένα αρχείου: εκτυπώνω κάθε γράμμα δεδομένων και τα γράφω ένα ένα. Το θεώρησα πιο σωστό από το να έχω
έναν buffer τον οποίο ή θα πρέπει να δεσμεύω δυναμικά κάθε φορά ή να κινδυνέψω σε περίπτωση που σταλεί μεγάλο
αρχείο να μην αντιγραφεί ολόκληρο.
    metadata: η ίδια λογική με το filename, μόνο που απλά τα εκτυπώνω και ύστερα κλείνω το αρχείο.
Η συνάρτηση dirmake ελέγχει αν το μονοπάτι που δόθηκε είναι ο local φάκελος και αν δεν είναι, παίρνει το
μονοπάτι αυτού του μονοπατιού, καλεί τον εαυτό της γι'αυτό το μονοπάτι και ύστερα δημιουργεί τον φάκελο
στο τέλος του μονοπατιού.
    Όταν η read τελειώσει, ο server έχει στείλει όλα τα αρχεία, άρα κλείνω το socket και ύστερα και τον
client.


Προσπάθησα να ακολουθήσω όσο πιο πιστά μπορώ την εκφώνηση και τις παρατηρήσεις στο piazza, τα προγράμματα
μεταγλωττίστηκαν και στους servers της σχολής και έτρεξαν, και τρέχουν με τις εντολές της εκφώνησης:

π.χ.
./dataServer -p 12500 -s 2 -q 2 -b 512

./remoteClient -i 127.0.0.1 -p 12500 -d Server